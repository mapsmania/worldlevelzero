<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body { background:#111;margin:0;overflow:hidden; }
  svg  { display:block;margin:auto; }
</style>
<body>
<svg width="960" height="500"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://unpkg.com/d3-geo-projection@4"></script>
<script>
const width = 960, height = 500;
const svg = d3.select("svg");
const path = d3.geoPath();

d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(world => {
  const countries = topojson.feature(world, world.objects.countries).features;

  const g = svg.append("g")
    .attr("fill", "#4CAF50")
    .attr("stroke", "#222")
    .selectAll("path")
    .data(countries)
    .join("path");

  // Define interpolators for scale and rotation to use during the animation phase
  // These will give a sense of continuous motion
  const scaleInterp = d3.interpolate(150, 200); 
  const rotateInterp = d3.interpolate([-10, 0], [-180, 0]); 

  let t = 0, dir = 1;
  
  function frame(){
    t += dir * 0.01;
    // Reverse direction at the limits [0, 1]
    if(t >= 1){t = 1; dir = -1;}
    if(t <= 0){t = 0; dir = 1;}

    let proj;

    // Use a normalized time 't_anim' (0 to 1) for interpolating parameters
    let t_anim = (t < 0.5) ? t * 2 : (t - 0.5) * 2; // Rescale t to 0-1 for each half cycle

    // 1. **Projection A (Mercator) for the first half of the cycle (t = 0 to 0.5)**
    if (t < 0.5) {
      proj = d3.geoMercator()
        // Interpolate parameters during this phase
        .scale(scaleInterp(t_anim))
        .rotate(rotateInterp(t_anim))
        .translate([width/2, height/2]);
        
    // 2. **Projection B (Mollweide) for the second half of the cycle (t = 0.5 to 1)**
    } else {
      // NOTE: Mollweide looks visually distinct from Mercator, giving the "switch" effect
      proj = d3.geoMollweide()
        // Interpolate parameters during this phase (you can reverse the interpolators for a smoother cycle)
        .scale(scaleInterp(1 - t_anim)) // Reverse the scale animation
        .rotate(rotateInterp(1 - t_anim)) // Reverse the rotation animation
        .translate([width/2, height/2]);
    }

    // Apply the current projection to the path generator
    path.projection(proj);
    
    // Update the 'd' attribute of the paths
    g.attr("d", d => path(d));
  }

  // run at ~20fps (every 50ms)
  d3.interval(frame, 50);
});
</script>
</body>
</html>
