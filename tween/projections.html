<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background: #111;
    margin: 0;
    overflow: hidden;
  }
  svg {
    display: block;
    margin: auto;
  }
</style>
<body>
<svg width="960" height="500"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script>

// --- Setup ---
const width = 960, height = 500;
const svg = d3.select("svg");

const projection = d3.geoMercator()
  .scale(150)
  .translate([width / 2, height / 2]);

const path = d3.geoPath(projection);

// --- Load World Data (simpler and faster than a custom GeoJSON) ---
d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(world => {

  const countries = topojson.feature(world, world.objects.countries).features;

  svg.append("g")
    .attr("class", "countries")
    .selectAll("path")
    .data(countries)
    .join("path")
    .attr("fill", "#4CAF50")
    .attr("stroke", "#222")
    .attr("d", path);

  // --- Projections ---
  const projA = d3.geoMercator().scale(150).translate([width/2, height/2]);
  const projB = d3.geoMollweide().scale(150).translate([width/2, height/2]);

  // --- Interpolator between projections ---
  function interpolateProjection(projA, projB, alpha) {
    const proj = d3.geoProjection((lambda, phi) => {
      const pA = projA([lambda * 180/Math.PI, phi * 180/Math.PI]);
      const pB = projB([lambda * 180/Math.PI, phi * 180/Math.PI]);
      if (!pA || !pB) return [NaN, NaN];
      return [
        pA[0] * (1 - alpha) + pB[0] * alpha,
        pA[1] * (1 - alpha) + pB[1] * alpha
      ];
    })
    .scale(150)
    .translate([width/2, height/2]);
    return proj;
  }

  // --- Animation ---
  function tweenProjections(pA, pB, duration = 6000) {
    d3.transition()
      .duration(duration)
      .ease(d3.easeCubicInOut)
      .tween("projection", () => {
        return t => {
          const newProj = interpolateProjection(pA, pB, t);
          path.projection(newProj);
          svg.selectAll("path").attr("d", path);
        };
      })
      .on("end", () => tweenProjections(pB, pA, duration)); // loop
  }

  tweenProjections(projA, projB, 6000);
});

</script>
</body>
</html>
