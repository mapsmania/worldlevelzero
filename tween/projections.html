<!doctype html>
<meta charset="utf-8">
<style>
  body { background:#111; color:#fff; font-family: sans-serif; margin:0; }
  header { padding:10px; display:flex; gap:8px; align-items:center; }
  button { padding:8px 12px; border-radius:6px; border:none; background:#222; color:#fff; cursor:pointer; }
  button.active { background:#4CAF50; }
  svg { display:block; margin:auto; }
  .label {
    font-size:22px;
    font-weight:600;
    fill:#fff;
    text-anchor:middle;
  }
</style>
<body>
<header>
  <div>
    <button data-from="mercator" data-to="mollweide" class="active">Mercator → Mollweide</button>
    <button data-from="mercator" data-to="robinson">Mercator → Robinson</button>
    <button data-from="orthographic" data-to="mollweide">Orthographic → Mollweide</button>
    <button id="play">Play</button>
  </div>
</header>

<svg id="map" width="960" height="520"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://unpkg.com/d3-geo-projection@4"></script>

<script>
(async function(){
  const width = 960, height = 520;
  const svg = d3.select("#map");
  const gA = svg.append("g").attr("class","layerA");
  const gB = svg.append("g").attr("class","layerB");

  // labels
  const labelA = svg.append("text").attr("class","label").attr("x", width/2).attr("y", height-20).style("opacity",1);
  const labelB = svg.append("text").attr("class","label").attr("x", width/2).attr("y", height-20).style("opacity",0);

  const path = d3.geoPath();

  function makeProjection(name){
    const s=150, c=[width/2,height/2];
    switch(name){
      case "mercator": return d3.geoMercator().scale(s).translate(c);
      case "mollweide": return d3.geoMollweide().scale(s).translate(c);
      case "robinson": return d3.geoRobinson().scale(s).translate(c);
      case "orthographic": return d3.geoOrthographic().scale(200).translate(c).clipAngle(90);
      default: return d3.geoMercator().scale(s).translate(c);
    }
  }

  const topo = await d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json");
  const countries = topojson.feature(topo, topo.objects.countries).features;

  function drawLayer(group, projName){
    const proj = makeProjection(projName);
    path.projection(proj);
    group.selectAll("path").data(countries).join("path")
      .attr("d", path)
      .attr("fill", "#4CAF50")
      .attr("stroke", "#111")
      .attr("stroke-width", 0.4);
    return proj;
  }

  // initial projection names
  let projAName = "mercator", projBName = "mollweide";
  drawLayer(gA, projAName);
  drawLayer(gB, projBName);

  // Initialize the visual state
  let activeLayer = gA, inactiveLayer = gB;
  let activeLabel = labelA, inactiveLabel = labelB;
  activeLayer.style("opacity",1);
  inactiveLayer.style("opacity",0);
  activeLabel.text(projAName[0].toUpperCase()+projAName.slice(1)).style("opacity",1);
  inactiveLabel.text(projBName[0].toUpperCase()+projBName.slice(1)).style("opacity",0);


  // safe async transition
  function fadeTransition(selection, targetOpacity, duration=1600){
    return new Promise(resolve=>{
      // **CRITICAL FIX:** Stop any existing transitions to prevent interference
      selection.interrupt().transition().duration(duration).ease(d3.easeCubicInOut).style("opacity",targetOpacity).on("end", resolve);
    });
  }

  async function crossfade(fromName, toName){
    // Draw the new 'to' projection onto the currently inactive layer
    drawLayer(inactiveLayer, toName);
    inactiveLabel.text(toName[0].toUpperCase()+toName.slice(1));
    
    // Ensure the incoming layer is on top for the fade-in
    inactiveLayer.raise(); activeLayer.raise(); // Re-raise both to ensure the right layer is on top
    inactiveLabel.raise(); activeLabel.raise();

    // Perform the crossfade: inactive IN (to 1), active OUT (to 0)
    await Promise.all([
      fadeTransition(activeLayer, 0),
      fadeTransition(inactiveLayer, 1),
      fadeTransition(activeLabel, 0),
      fadeTransition(inactiveLabel, 1)
    ]);
    
    // **CRITICAL STEP:** SWAP the layer references for the next transition
    [activeLayer, inactiveLayer] = [inactiveLayer, activeLayer];
    [activeLabel, inactiveLabel] = [inactiveLabel, activeLabel];
    
    // Now, the layer that just faded IN is the new activeLayer, and vice-versa.
  }

  // button handlers (modified to reset the visual state)
  d3.selectAll("button[data-from]").on("click",async function(){
    d3.selectAll("button[data-from]").classed("active",false);
    d3.select(this).classed("active",true);
    
    // Stop the loop if playing
    playing = false; 
    d3.select("#play").text("Play");

    // Reset initial state to Mercator -> Mollweide (or whatever is clicked)
    projAName = this.dataset.from;
    projBName = this.dataset.to;

    // Reset visual layers to initial state (gA visible, gB hidden)
    activeLayer = gA; inactiveLayer = gB;
    activeLabel = labelA; inactiveLabel = labelB;

    // Redraw and reset opacity/text immediately
    drawLayer(activeLayer, projAName);
    drawLayer(inactiveLayer, projBName);
    activeLayer.style("opacity", 1);
    inactiveLayer.style("opacity", 0);
    
    activeLabel.text(projAName[0].toUpperCase()+projAName.slice(1)).style("opacity",1);
    inactiveLabel.text(projBName[0].toUpperCase()+projBName.slice(1)).style("opacity",0);
  });

  let playing=false;
  d3.select("#play").on("click",function(){
    playing=!playing;
    d3.select(this).text(playing?"Stop":"Play");
    if(playing) runLoop();
  });

  // looping crossfade (simplified)
  async function runLoop(){
    while(playing){
      // Fade from current active (projAName) to new (projBName)
      await crossfade(projAName, projBName);
      await new Promise(r=>setTimeout(r,600));

      // The activeLayer and inactiveLayer variables have been swapped inside crossfade.
      // Now, simply swap the projection names for the next cycle
      [projAName, projBName] = [projBName, projAName]; 
    }
  }

})();
</script>
