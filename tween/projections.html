<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background: #111;
    color: white;
    overflow: hidden;
  }
  svg {
    display: block;
    margin: auto;
  }
</style>
<body>
<svg width="960" height="500"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>

// SVG setup
const width = 960, height = 500;
const svg = d3.select("svg");

// Initial projection and path
let projection = d3.geoMercator().scale(150).translate([width/2, height/2]);
let path = d3.geoPath().projection(projection);

// Load data
d3.json("https://mapsmania.github.io/worldlevelzero/world/world.geojson").then(world => {

  svg.append("g")
    .selectAll("path")
    .data(world.features)
    .join("path")
      .attr("fill", "#4CAF50")
      .attr("stroke", "#222")
      .attr("d", path);

  // Define two projections to tween between
  const projA = d3.geoMercator().scale(150).translate([width/2, height/2]);
  const projB = d3.geoMollweide().scale(150).translate([width/2, height/2]);

  // Tween function
  function projectionTween(projA, projB, duration = 5000) {
    d3.transition()
      .duration(duration)
      .tween("projection", () => {
        const interp = d3.interpolate(0, 1);
        return t => {
          const newProj = d3.geoProjection((lambda, phi) => {
            const a = projA([lambda * 180/Math.PI, phi * 180/Math.PI]);
            const b = projB([lambda * 180/Math.PI, phi * 180/Math.PI]);
            return [
              a[0] * (1 - t) + b[0] * t,
              a[1] * (1 - t) + b[1] * t
            ];
          })
          .scale(150)
          .translate([width/2, height/2]);
          path.projection(newProj);
          svg.selectAll("path").attr("d", path);
        };
      }
