<!doctype html>
<meta charset="utf-8">
<style>
  body { background:#111; color:#fff; font-family: sans-serif; margin:0; }
  header { padding:10px; display:flex; gap:8px; align-items:center; }
  button { padding:8px 12px; border-radius:6px; border:none; background:#222; color:#fff; cursor:pointer; }
  button.active { background:#4CAF50; }
  svg { display:block; margin:auto; }
  .label {
    font-size:22px;
    font-weight:600;
    fill:#fff;
    text-anchor:middle;
  }
</style>
<body>
<header>
  <div>
    <button data-from="mercator" data-to="mollweide" class="active">Mercator → Mollweide</button>
    <button data-from="mercator" data-to="robinson">Mercator → Robinson</button>
    <button data-from="orthographic" data-to="mollweide">Orthographic → Mollweide</button>
    <button id="play">Play</button>
  </div>
</header>

<svg id="map" width="960" height="520"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://unpkg.com/d3-geo-projection@4"></script>

<script>
(async function(){
  const width = 960, height = 520;
  const svg = d3.select("#map");
  const gA = svg.append("g").attr("class","layerA");
  const gB = svg.append("g").attr("class","layerB");

  // create two labels
  const labelA = svg.append("text")
      .attr("class","label")
      .attr("x", width/2)
      .attr("y", height-20)
      .style("opacity",1);

  const labelB = svg.append("text")
      .attr("class","label")
      .attr("x", width/2)
      .attr("y", height-20)
      .style("opacity",0);

  const path = d3.geoPath();

  function makeProjection(name){
    const s=150, c=[width/2,height/2];
    switch(name){
      case "mercator":     return d3.geoMercator().scale(s).translate(c);
      case "mollweide":    return d3.geoMollweide().scale(s).translate(c);
      case "robinson":     return d3.geoRobinson().scale(s).translate(c);
      case "orthographic": return d3.geoOrthographic().scale(200).translate(c).clipAngle(90);
      default:             return d3.geoMercator().scale(s).translate(c);
    }
  }

  const topo = await d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json");
  const countries = topojson.feature(topo, topo.objects.countries).features;

  function drawLayer(group, projName){
    const proj = makeProjection(projName);
    path.projection(proj);
    group.selectAll("path")
      .data(countries)
      .join("path")
      .attr("d", path)
      .attr("fill", "#4CAF50")
      .attr("stroke", "#111")
      .attr("stroke-width", 0.4);
    return proj;
  }

  let projAName = "mercator", projBName = "mollweide";
  drawLayer(gA, projAName);
  drawLayer(gB, projBName);
  gA.style("opacity",1);
  gB.style("opacity",0);
  labelA.text(projAName[0].toUpperCase()+projAName.slice(1));
  labelB.text(projBName[0].toUpperCase()+projBName.slice(1));

  async function crossfade(fromName,toName,duration=1800){
    drawLayer(gA, fromName);
    drawLayer(gB, toName);
    labelA.text(fromName[0].toUpperCase()+fromName.slice(1));
    labelB.text(toName[0].toUpperCase()+toName.slice(1));

    gA.raise();
    labelA.raise();
    labelB.raise();

    // fade map layers
    gA.transition().duration(duration).ease(d3.easeCubicInOut).style("opacity",0);
    gB.transition().duration(duration).ease(d3.easeCubicInOut).style("opacity",1);

    // fade labels in sync
    labelA.transition().duration(duration).ease(d3.easeCubicInOut).style("opacity",0);
    labelB.transition().duration(duration).ease(d3.easeCubicInOut).style("opacity",1);

    await new Promise(r=>setTimeout(r,duration+50));
  }

  d3.selectAll("button[data-from]").on("click",function(){
    d3.selectAll("button[data-from]").classed("active",false);
    d3.select(this).classed("active",true);
    projAName=this.dataset.from;
    projBName=this.dataset.to;
    gA.style("opacity",1);
    gB.style("opacity",0);
    labelA.style("opacity",1);
    labelB.style("opacity",0);
    drawLayer(gA,projAName);
    drawLayer(gB,projBName);
    labelA.text(projAName[0].toUpperCase()+projAName.slice(1));
    labelB.text(projBName[0].toUpperCase()+projBName.slice(1));
  });

  let playing=false;
  d3.select("#play").on("click",function(){
    playing=!playing;
    d3.select(this).text(playing?"Stop":"Play");
    if(playing) runLoop();
  });

  async function runLoop(){
    while(playing){
      await crossfade(projAName, projBName, 1600);
      await new Promise(r=>setTimeout(r,600));
      await crossfade(projBName, projAName, 1600);
      await new Promise(r=>setTimeout(r,600));
    }
  }
})();
</script>
