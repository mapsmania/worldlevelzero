<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background: #111;
    margin: 0;
    overflow: hidden;
  }
  svg {
    display: block;
    margin: auto;
  }
</style>
<body>
<svg width="960" height="500"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://unpkg.com/d3-geo-projection@4"></script>
<script>

// --- Setup ---
const width = 960, height = 500;
const svg = d3.select("svg");

const path = d3.geoPath();

// --- Load World Data ---
d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(world => {

  const countries = topojson.feature(world, world.objects.countries).features;

  svg.append("g")
    .attr("class", "countries")
    .selectAll("path")
    .data(countries)
    .join("path")
    .attr("fill", "#4CAF50")
    .attr("stroke", "#222");

  // --- Projections ---
  const projA = d3.geoMercator().scale(150).translate([width/2, height/2]);
  const projB = d3.geoMollweide().scale(150).translate([width/2, height/2]);

  // --- Safe interpolation between projections ---
  function interpolateProjection(projA, projB, alpha) {
    const proj = d3.geoProjection((lambda, phi) => {
      const lon = lambda * 180 / Math.PI;
      const lat = phi * 180 / Math.PI;
      const pA = projA([lon, lat]);
      const pB = projB([lon, lat]);

      if (!pA || !pB || !isFinite(pA[0]) || !isFinite(pA[1]) || !isFinite(pB[0]) || !isFinite(pB[1])) {
        // return invalid so D3 skips it
        return [NaN, NaN];
      }
      return [
        pA[0] * (1 - alpha) + pB[0] * alpha,
        pA[1] * (1 - alpha) + pB[1] * alpha
      ];
    })
    .scale(150)
    .translate([width / 2, height / 2]);
    return proj;
  }

  // --- Animation ---
  function tweenProjections(pA, pB, duration = 6000) {
    d3.transition()
      .duration(duration)
      .ease(d3.easeCubicInOut)
      .tween("projection", () => {
        return t => {
          const newProj = interpolateProjection(pA, pB, t);
          path.projection(newProj);
          svg.selectAll("path")
            .attr("d", d => {
              try {
                const p = path(d);
                if (!p || p.includes("NaN")) return null;
                return p;
              } catch {
                return null;
              }
            });
        };
      })
      .on("end", () => tweenProjections(pB, pA, duration)); // loop
  }

  tweenProjections(projA, projB, 6000);
});

</script>
</body>
</html>
